import math

# Функция, минимум которой нужно найти
def f(x):
    return 2 ** x - 2 * x ** 2 + 1 # Определяем функцию f(x)

# Обратная квадратичная интерполяция для поиска минимума
def inverse_quadratic_interpolation_min(f, x1, x2, x3, tol=0.0001, max_iter=100):
    """
    Поиск минимума функции с использованием обратной квадратичной интерполяции.

    Параметры:
        f: Функция, минимум которой нужно найти.
        x1, x2, x3: Начальные точки.
        tol: Точность (критерий остановки).
        max_iter: Максимальное количество итераций.

    Возвращает:
        x_min: Приближение к точке минимума.
    """
    for i in range(max_iter):  # Цикл по максимальному количеству итераций
        # Вычисляем значения функции в заданных точках
        f1, f2, f3 = f(x1), f(x2), f(x3)

        # Коэффициенты квадратичной аппроксимации
        denominator = ((x1 ** 2 - x2 ** 2) * (x2 - x3) - (x2 ** 2 - x3 ** 2) * (x1 - x2))
        if abs(denominator) < 1e-10:  # Проверка на близость к нулю
            # Если знаменатель близок к нулю, используем простое среднее значение
            x_new = (x1 + x2 + x3) / 3
        else:
            # Вычисляем коэффициенты A, B и C для квадратичной интерполяции
            A = ((f2 - f3) * (x1 - x2) - (f1 - f2) * (x2 - x3)) / denominator
            B = ((f1 - f2) - A * (x1 ** 2 - x2 ** 2)) / (x1 - x2)
            C = f1 - A * x1 ** 2 - B * x1

            # Минимум квадратичной аппроксимации
            if abs(A) < 1e-10:  # Проверка на близость к нулю
                x_new = (x1 + x2 + x3) / 3  # Используем среднее значение
            else:
                x_new = -B / (2 * A)  # Находим новое значение x_new

        # Проверка, что x_new находится внутри интервала [x1, x3]
        if x_new < x1 or x_new > x3:
            x_new = (x1 + x3) / 2  # Используем середину интервала

        # Проверка на сходимость
        if abs(x_new - x2) < tol:
            print(f"Решение сошлось за {i + 1} итераций.")
            return x_new  # Возвращаем найденный минимум

        # Обновление точек для следующей итерации
        if x_new < x2:
            x1, x2, x3 = x1, x_new, x2  # Обновляем точки
        else:
            x1, x2, x3 = x2, x_new, x3  # Обновляем точки

    print("Метод не сошелся за максимальное количество итераций.")
    return x2  # Возвращаем последнее значение x2, если не сошлось

# Пример использования

# Начальные точки (выбираем вблизи предполагаемого минимума)
x1, x2, x3 = 4, 5, 4.5

# Поиск минимума
x_min = inverse_quadratic_interpolation_min(f, x1, x2, x3)
print("Минимум функции находится в точке:", x_min)
print("Значение функции в минимуме:", f(x_min))

# Визуализация
import matplotlib.pyplot as plt

x_plot = [i * 0.1 for i in range(0, 50)]  # Точки для построения графика
y_plot = [f(x) for x in x_plot]  # Значения функции

plt.figure(figsize=(10, 6))
plt.plot(x_plot, y_plot, label='Функция')  # Построение графика функции
plt.scatter(x_min, f(x_min), color='red', label='Минимум')  # Отметка минимума на графике
plt.xlabel('x')
plt.ylabel('y')
plt.title('Поиск минимума функции методом обратной квадратичной интерполяции')
plt.legend()
plt.grid(True)
plt.show()  # Отображение графика
